load ../../../k-prelude
mod BEFUNGE is
	including K-PROPER .
	including K-MAP-EXTRAS .
	including K-RULES .
	including K-CONFIG .
	including PL-BUILTINS .
	
	including K-OPEN-CELLS .
	---including K-WRAPPERS-LABELS . --- can't include this?
	
	including K .
--- Syntax
	---- Comments from Chris Pressey, http://catseye.tc/projects/befunge93/doc/befunge93.html
	--- COMMAND         INITIAL STACK (bot->top)	RESULT (STACK)
	----        		 -------------           -----------------
	--- + (add)         <value1> <value2>       <value1 + value2>
	--- - (subtract)    <value1> <value2>       <value1 - value2>
	--- / (divide)      <value1> <value2>       <value1 / value2> (nb. integer)
	--- * (multiply)    <value1> <value2>       <value1 * value2>
	--- % (modulo)      <value1> <value2>       <value1 mod value2>
	
	--- ! (not)         <value>                 <0 if value non-zero, 1 otherwise>
	--- ` (greater)     <value1> <value2>       <1 if value1 > value2, 0 otherwise>
	
	--- > (right)                               PC -> right
	--- < (left)                                PC -> left
	--- ^ (up)                                  PC -> up
	--- v (down)                                PC -> down
	--- ? (random)                              PC -> right? left? up? down? ???
	
	--- _ (horizontal if) <boolean value>       PC->left if <value>, else PC->right
	--- | (vertical if)   <boolean value>       PC->up if <value>, else PC->down
	
	--- " (stringmode)                          Toggles 'stringmode'
	
	--- : (dup)         <value>                 <value> <value>
	--- # (bridge)                              'jumps' PC one farther; skips over next command
	
	--- \ (swap)        <value1> <value2>       <value2> <value1>
	--- $ (pop)         <value>                 pops <value> but does nothing
	
	--- . (output value)	<value>             outputs <value> as integer
	--- , (output character)	<value>         outputs <value> as ASCII
	--- & (input value)                         <value user entered>
	--- ~ (input character)                     <character user entered>
	
	--- @ (end)                                 ends program
	
	--- g (get)         <x> <y>                 <value at (x,y)>
	--- p (put)         <value> <x> <y>         puts <value> at (x,y)
	
	--- [space] (nop)

	---------
	--- e.g.:
	--- command('$', pop(.List{K}))
	--- command(' ', nop(.List{K}))
	--- command('x', err(.List{K}))
	--- command('4', push(inject(4)(.List{K}))
	
--- Configuration
	op stack : -> CellLabel .
	op direction : -> CellLabel .
	op mode : -> CellLabel .
	op program : -> CellLabel .
	op pc : -> CellLabel .
	op output : -> CellLabel .
	op input : -> CellLabel .
	op k : -> CellLabel .
	op result : -> CellLabel .
	
--- Semantics
	op eval : K -> Bag .
	op eval : K K -> Bag .
	op inject : Int -> KLabel .
	op inject : Char -> KLabel .
	op inject : String -> KLabel .
	op injectM : Map -> KLabel .
	op injectL : List -> KLabel .
	
	op coord : -> KLabel .
	op load : -> KLabel .
	op defaultmode : -> KLabel .
	op movePC : -> KLabel .
	op stringmode : -> KLabel .
	op push : -> KLabel .
	
	op right : -> KLabel .
	op left : -> KLabel .
	op up : -> KLabel .
	op down : -> KLabel .
	
	mb configuration 
		< T >
			< k > K:K </ k >
			< stack > L:List </ stack >
			< direction > K:K </ direction >
			< pc > K:K </ pc >
			< mode > K:K </ mode >
			< program > M:Map </ program >
			< output > K:K </ output >
			< input > L:List </ input >
		</ T >  
		< result > K:K </ result > 
		: KSentence .
	
	eq [Start]: eval(injectM(M:Map)(.List{K})) =
		< T >
			< k > .K </ k >
			< stack > .List </ stack >
			< direction > right(.List{K}) </ direction >
			< pc > coord(inject(0)(.List{K}),, inject(0)(.List{K})) </ pc >
			< mode > defaultmode(.List{K}) </ mode >
			< program > M:Map </ program >
			< output > inject("")(.List{K}) </ output >
			< input > .List </ input >
		</ T > .
	eq [Start-With-Input]: eval(injectM(M:Map)(.List{K}), injectL(L:List)(.List{K})) =
		< T >
			< k > .K </ k >
			< stack > .List </ stack >
			< direction > right(.List{K}) </ direction >
			< pc > coord(inject(0)(.List{K}),, inject(0)(.List{K})) </ pc >
			< mode > defaultmode(.List{K}) </ mode >
			< program > M:Map </ program >
			< output > inject("")(.List{K}) </ output >
			< input > L:List </ input >
		</ T > .
		
	mb [Finish]: rule [
		< T > S:Bag < k > inject("@")(.List{K}) ...</ k > < output > K:K </ output > </ T > 
			=> < result > K:K </ result >
		] : KSentence [metadata "structural"] .
		
	---------------------------
	---- very structural
	
	mb [Next]: rule
		< k > [.K => load(.List{K}) ~> movePC(.List{K})] </ k >
		: KSentence [metadata "structural"] .
		
	mb [startStack]: rule
		< stack > [.List => List(inject(0)(.List{K}))] </ stack >
		: KSentence [metadata "structural"] .
	mb [refillStack]: rule
		< stack > [Li:ListItem => Li:ListItem List(inject(0)(.List{K}))] </ stack >
		: KSentence [metadata "structural"] .
	
	mb [Load]: rule
		< k > [load(.List{K}) => inject(C:Char)(.List{K})] ...</ k >
		< pc > Loc:K </ pc >
		< program >... Loc:K |-> inject(C:Char)(.List{K}) ...</ program >
		: KSentence [metadata "structural"] .
	mb [Load]: rule
		< k > [load(.List{K}) => inject(" ")(.List{K})] ...</ k >
		< pc > coord(inject(X:Int)(.List{K}),, inject(Y:Int)(.List{K})) </ pc >
		< program > M:Map </ program >
		if notBool($hasMapping(M:Map, coord(inject(X:Int)(.List{K}),, inject(Y:Int)(.List{K}))))
			andBool (X:Int >=Int 0)
			andBool (Y:Int >=Int 0)
			andBool (X:Int <Int 80)
			andBool (Y:Int <Int 25)
		: KSentence [metadata "structural"] .
	
	mb [MovePC-right]: rule 
		< k > [movePC(.List{K}) => .K] ...</ k >
		< direction > right(.List{K}) </ direction >
		< pc > coord(inject([I:Int => (I:Int +Int 1) %Int 80])(.List{K}),, K:K) </ pc >
		: KSentence [metadata "structural"] .
	mb [MovePC-left]: rule 
		< k > [movePC(.List{K}) => .K] ...</ k >
		< direction > left(.List{K}) </ direction >
		< pc > coord(inject([I:Int => ((I:Int -Int 1) +Int 80) %Int 80])(.List{K}),, K:K) </ pc >
		: KSentence [metadata "structural"] .
	mb [MovePC-up]: rule 
		< k > [movePC(.List{K}) => .K] ...</ k >
		< direction > up(.List{K}) </ direction >
		< pc > coord(K:K,, inject([I:Int => ((I:Int -Int 1) +Int 25) %Int 25])(.List{K})) </ pc >
		: KSentence [metadata "structural"] .
	mb [MovePC-down]: rule 
		< k > [movePC(.List{K}) => .K] ...</ k >
		< direction > down(.List{K}) </ direction >
		< pc > coord(K:K,, inject([I:Int => (I:Int +Int 1) %Int 25])(.List{K})) </ pc >
		: KSentence [metadata "structural"] .
				
	---op asAscii : -> KLabel .
	---eq asAscii(inject(S:String)(.List{K})) = inject(asciiString(S:String))(.List{K}) .
		
	op charToAscii : -> KProperLabel [metadata "arity 1"] .
	mb [charToAscii]: rule
		[charToAscii(inject(C:Char)(.List{K})) => inject(asciiString(C:Char))(.List{K})]
		: KSentence [metadata "structural"] .
		
	op charToNumber : -> KProperLabel [metadata "arity 1"] .
	mb [charToNumber]: rule
		[charToNumber(inject(C:Char)(.List{K})) => inject(asciiString(C:Char) -Int asciiString("0"))(.List{K})]
		: KSentence [metadata "structural"] .
	---- end structural
	---------------------------

	mb [stringmode-on]: rule
		< k > [inject("\"")(.List{K}) => .K] ...</ k >
		< mode > [defaultmode(.List{K}) => stringmode(.List{K})] </ mode >
		: KSentence [metadata "computational rule"] .
	mb [stringmode-off]: rule
		< k > [inject("\"")(.List{K}) => .K] ...</ k >
		< mode > [stringmode(.List{K}) => defaultmode(.List{K})] </ mode >
		: KSentence [metadata "computational rule"] .
	mb [stringmode-push]: rule
		< k > [inject(C:Char)(.List{K}) => push(charToAscii(inject(C:Char)(.List{K})))] ...</ k >
		< mode > stringmode(.List{K}) </ mode >
		if (C:Char =/=Bool "\"")
		: KSentence [metadata "structural"] .
	mb [defaultmode-push-number]: rule
		< k > [inject(C:Char)(.List{K}) => push(charToNumber(inject(C:Char)(.List{K})))] ...</ k >
		< mode > defaultmode(.List{K}) </ mode >
		if (C:Char ==Bool "0") 
			orBool (C:Char ==Bool "1") 
			orBool (C:Char ==Bool "2")
			orBool (C:Char ==Bool "3") 
			orBool (C:Char ==Bool "4")
			orBool (C:Char ==Bool "5")
			orBool (C:Char ==Bool "6")
			orBool (C:Char ==Bool "7")
			orBool (C:Char ==Bool "8")
			orBool (C:Char ==Bool "9")
		: KSentence [metadata "structural"] .
		
	
	mb [push]: rule
		< k > [push(K:K) => .K] ...</ k >
		< stack > [.List => List(K:K)] ...</ stack >
		: KSentence [metadata "computational rule"] .
		
	mb [right]: rule
		< k > [inject(">")(.List{K}) => .K] ...</ k >
		< direction > [K:K => right(.List{K})] </ direction >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
	mb [left]: rule
		< k > [inject("<")(.List{K}) => .K] ...</ k >
		< direction > [K:K => left(.List{K})] </ direction >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
	mb [up]: rule
		< k > [inject("^")(.List{K}) => .K] ...</ k >
		< direction > [K:K => up(.List{K})] </ direction >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
	mb [down]: rule
		< k > [inject("v")(.List{K}) => .K] ...</ k >
		< direction > [K:K => down(.List{K})] </ direction >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .		
		
	--- : is the duplication command.  It makes a copy of the top element of the stack
	mb [dup]: rule
		< k > [inject(":")(.List{K}) => .K] ...</ k >
		< stack > [Li:ListItem => Li:ListItem  Li:ListItem] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .	
	
	--- # is the 'bridge' command... it causes the next command which would normally be executed to be skipped over, and not executed.
	mb [bridge]: rule
		< k > [inject("#")(.List{K}) => movePC(.List{K})] ...</ k >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .	
		
	--- The standard 'if' statement in Befunge-93 is either _ or |, depending on how you want to branch.  Both of these instructions pop a value off the stack and check to see if it is true (non-zero,) and change the direction of the PC accordingly:
	--- _ acts like < if the value is true or > if it is false; and
	mb [horizontalIf-false]: rule
		< k > [inject("_")(.List{K}) => inject(">")(.List{K})] ...</ k >
		< stack > [List(inject(0)(.List{K})) => .List] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .	
	mb [horizontalIf-true]: rule
		< k > [inject("_")(.List{K}) => inject("<")(.List{K})] ...</ k >
		< stack > [List(inject(I:Int)(.List{K})) => .List] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		if (I:Int =/=Bool 0)
		: KSentence [metadata "computational rule"] .
    --- | acts like ^ if the value is true or v if it is false.
	mb [verticalIf-false]: rule
		< k > [inject("|")(.List{K}) => inject("v")(.List{K})] ...</ k >
		< stack > [List(inject(0)(.List{K})) => .List] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .	
	mb [verticalIf-true]: rule
		< k > [inject("|")(.List{K}) => inject("^")(.List{K})] ...</ k >
		< stack > [List(inject(I:Int)(.List{K})) => .List] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		if (I:Int =/=Bool 0)
		: KSentence [metadata "computational rule"] .
		
	
	--- The . command will pop a value off the stack and output it as a decimal integer, followed by a space, somewhat like Forth. 
	mb [printNumber]: rule
		< k > [inject(".")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(I:Int)(.List{K})) => .List] ...</ stack >
		< output > inject([S:String => S:String +String stringConversion(absInt(I:Int), 10) +String " "])(.List{K}) </ output >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
		
	--- ,  will pop a value, interpret it as the ASCII value of a character, and output that character (not followed by a space.)
	mb [printCharacter]: rule
		< k > [inject(",")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(I:Int)(.List{K})) => .List] ...</ stack >
		< output > inject([S:String => S:String +String charString(absInt(I:Int %Int 256))])(.List{K}) </ output >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
		
	--- The & (ampersand) command will get a numeric value (in decimal) from the standard input and push it on the stack. ~ (tilde) will get the next ASCII character from standard input and push it on the stack.
	mb [readNumber]: rule
		< k > [inject("&")(.List{K}) => .K] ...</ k >
		< stack > [.List => Li:ListItem] ...</ stack >
		< input > [Li:ListItem => .List] ...</ input >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
	
	--- --- Note that   (space) is a null command which does nothing.
	mb [nop]: rule
		< k > [inject(" ")(.List{K}) => .K] ...</ k >	
		< mode > defaultmode(.List{K}) </ mode >		
		: KSentence [metadata "computational rule"] .
		
	mb [pop]: rule
		< k > [inject("$")(.List{K}) => .K] ...</ k >
		< stack > [Li:ListItem => .List] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >		
		: KSentence [metadata "computational rule"] .
	
	mb [swap]: rule
		< k > [inject("\\")(.List{K}) => .K] ...</ k >
		< stack > [Li1:ListItem Li2:ListItem => Li2:ListItem Li1:ListItem] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
	
	--- g (get)         <x> <y>                 <value at (x,y)>
	mb [metaGet]: rule
		< k > [inject("g")(.List{K}) => .K] ...</ k >
		< stack > [List(Y:K) List(X:K) => List(charToAscii(K:K))] ...</ stack >
		< program >... coord(X:K,, Y:K) |-> K:K ...</ program >
		< mode > defaultmode(.List{K}) </ mode >	
		: KSentence [metadata "computational rule"] .
	mb [metaGet]: rule
		< k > [inject("g")(.List{K}) => .K] ...</ k >
		< stack > [List(Y:K) List(X:K) => List(charToAscii(inject(" ")(.List{K})))] ...</ stack >
		< program > M:Map </ program >
		< mode > defaultmode(.List{K}) </ mode >
		if notBool($hasMapping(M:Map, coord(X:K,, Y:K)))
		: KSentence [metadata "computational rule"] .
		
	--- p (put)         <value> <x> <y>         puts <value> at (x,y)
	--- should not be absval
	mb [metaGet]: rule
		< k > [inject("p")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(Y:Int)(.List{K})) List(inject(X:Int)(.List{K})) List(inject(V:Int)(.List{K})) => .List] ...</ stack >
		< program > [M:Map => M:Map[inject(charString(absInt(V:Int %Int 256)))(.List{K}) / coord(inject(X:Int)(.List{K}),, inject(Y:Int)(.List{K}))]] </ program >
		< mode > defaultmode(.List{K}) </ mode >
		if (X:Int >=Int 0)		
			andBool (Y:Int >=Int 0)
			andBool (X:Int <Int 80)
			andBool (Y:Int <Int 25)
		: KSentence [metadata "computational rule"] .
		
	--- ! (not)         <value>                 <0 if value non-zero, 1 otherwise>
	mb [not]: rule
		< k > [inject("!")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(I:Int)(.List{K})) => List(inject(if (I:Int ==Bool 0) then 1 else 0 fi)(.List{K}))] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >		
		: KSentence [metadata "computational rule"] .
	--- ` (greater)     <value1> <value2>       <1 if value1 > value2, 0 otherwise
	mb [greater]: rule
		< k > [inject("`")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(I2:Int)(.List{K})) List(inject(I1:Int)(.List{K})) => List(inject(if (I1:Int >Int I2:Int) then 1 else 0 fi)(.List{K}))] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >		
		: KSentence [metadata "computational rule"] .
		
	mb [add]: rule
		< k > [inject("+")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(I1:Int)(.List{K})) List(inject(I2:Int)(.List{K})) => List(inject(I2:Int +Int I1:Int)(.List{K}))] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
	mb [subtract]: rule
		< k > [inject("-")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(I1:Int)(.List{K})) List(inject(I2:Int)(.List{K})) => List(inject(I2:Int -Int I1:Int)(.List{K}))] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
	mb [multiply]: rule
		< k > [inject("*")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(I1:Int)(.List{K})) List(inject(I2:Int)(.List{K})) => List(inject(I2:Int *Int I1:Int)(.List{K}))] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
	mb [divide]: rule
		< k > [inject("/")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(I1:Int)(.List{K})) List(inject(I2:Int)(.List{K})) => List(inject(I2:Int /Int I1:Int)(.List{K}))] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .
	mb [modulo]: rule
		< k > [inject("%")(.List{K}) => .K] ...</ k >
		< stack > [List(inject(I1:Int)(.List{K})) List(inject(I2:Int)(.List{K})) => List(inject(I2:Int %Int I1:Int)(.List{K}))] ...</ stack >
		< mode > defaultmode(.List{K}) </ mode >
		: KSentence [metadata "computational rule"] .	
endm
