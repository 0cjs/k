load ../../../k-prelude
mod THUE is
	including K-PROPER .
	including K-MAP-EXTRAS .
	including K-RULES .
	including K-CONFIG .
	including PL-INT .
	including PL-STRING .
	including K-LIST-EXTRAS .
	including K-OPEN-CELLS .
	including K-ANONYMOUS-VARIABLES .
	---including K-WRAPPERS-LABELS . --- can't include this?
	
	including K .
--- Syntax
	op subst : -> KProperLabel [metadata "arity 2"] .
	op write : -> KProperLabel [metadata "arity 2"] .
	op read : -> KProperLabel [metadata "arity 2"] .
	op start : -> KProperLabel [metadata "arity 1"] .
	
--- Configuration
	op output : -> CellLabel .
	op input : -> CellLabel .
	op k : -> CellLabel .
	op rules : -> CellLabel .
	op someRules : -> CellLabel .
	op disabled : -> CellLabel .
	op result : -> CellLabel .
	
	mb configuration 
	< T >
		< k > K:K </ k >
		< someRules > S:Bag </ someRules >
		< rules > S:Bag </ rules >
		< disabled > S:Bag </ disabled >
		< output > K:K </ output >
		< input > L:List </ input >
	</ T >  
	< result > K:K </ result > 
	: KSentence .
	
--- Semantics
	op eval : K -> Bag .
	op eval : K K -> Bag .
	op inject : Char -> KLabel .
	op inject : String -> KLabel .
	op injectM : Map -> KLabel .
	op injectL : List -> KLabel .

	op explode : -> KProperLabel [metadata "arity 1"] .
	op join : -> KProperLabel [metadata "arity 1"] .
	op string : -> KLabel .
	
	---- define explode of a string
	mb [explodeString]: rule
		explode([inject(S:String)(.List{K}) => inject(substrString(S:String, 1, lengthString(S:String)))(.List{K})] ~> K:K ~> [.K => inject(substrString(S:String, 0, 1))(.List{K})])
		if notBool(S:String ==Bool "")
		: KSentence [metadata "computational rule"] .
	mb rule
		[explode(inject("")(.List{K}) ~> K:K) => K:K]
		: KSentence [metadata "computational rule"] .
	---- end define explode of a string
	
	eq [Start]: eval(K:K) =
	< T >
		< k > K:K </ k >
		< someRules > .Bag </ someRules >
		< disabled > .Bag </ disabled >
		< output > .K </ output >
		< input > .List </ input >
	</ T > .
	eq [StartWithInput]: eval(K1:K, injectL(L:List)(.List{K})) =
	< T >
		< k > K1:K </ k >
		< someRules > .Bag </ someRules >
		< disabled > .Bag </ disabled >
		< output > .K </ output >
		< input > L:List </ input >
	</ T > .
	
	--- explode should be in kind, makes things complicated otherwise
	mb [doneLoadingRules]: rule
		< k > [start(K:K) => explode(K:K)] </ k >
		< [someRules => rules] > S:Bag </ [someRules => rules] >
		: KSentence [metadata "computational rule"] .
		
	mb [saveRule]: rule
		< k > [subst(K1:K,, K2:K) => .K] ...</ k >
		< someRules >... [.Bag => Bag(subst(explode(K1:K),, explode(K2:K)))] ...</ someRules >
		: KSentence [metadata "computational rule"] .
	mb [saveWrite]: rule
		< k > [write(K1:K,, K2:K) => .K] ...</ k >
		< someRules >... [.Bag => Bag(write(explode(K1:K),, explode(K2:K)))] ...</ someRules >
		: KSentence [metadata "computational rule"] .
	mb [saveRead]: rule
		< k > [read(K:K) => .K] ...</ k >
		< someRules >... [.Bag => Bag(read(explode(K:K)))] ...</ someRules >
		: KSentence [metadata "computational rule"] .
		
	mb [applyRule]: rule
		< k >... [K1:K => K2:K] ...</ k >
		< rules >... Bag(subst(K1:K,, K2:K)) [.Bag => D:Bag] ...</ rules >
		< disabled > [D:Bag => .Bag] </ disabled >
		: KSentence [metadata "computational rule"] .
	mb [applyWrite]: rule
		< k >... [K1:K => .K] ...</ k >
		< rules >... Bag(write(K1:K,, K2:K)) [.Bag => D:Bag] ...</ rules >
		< disabled > [D:Bag => .Bag] </ disabled >
		< output >... [.K => K2:K] </ output >
		: KSentence [metadata "computational rule"] .
	mb [applyRead]: rule
		< k >... [K1:K => explode(K2:K)] ...</ k >
		< rules >... Bag(read(K1:K)) [.Bag => D:Bag] ...</ rules >
		< disabled > [D:Bag => .Bag] </ disabled >
		< input >[List(K2:K) => .List] ...</ input >
		: KSentence [metadata "computational rule"] .
	
	--- mb [disabledRule]: rule
		--- < k > K2:K </ k >
		--- < rules >... [Bag(L:KLabel(K1:K,, Kl:List{K})) => .Bag] ...</ rules >
		--- < disabled >... [.Bag => Bag(L:KLabel(K1:K,, Kl:List{K}))] ...</ disabled >
		--- if notBool(inKList(K1:K, K2:K))
		--- : KSentence [metadata "computational rule"] .
		
	mb [disabledRead]: rule
		< k > K2:K </ k >
		< rules >... [Bag(read(K1:K)) => .Bag] ...</ rules >
		< disabled >... [.Bag => Bag(read(K1:K))] ...</ disabled >
		if notBool(inKList(K1:K, K2:K))
		: KSentence [metadata "computational rule"] .
	
	
	--- mb [finish]: rule
		--- [< T >... 
			--- < rules > .Bag </ rules >
			--- < output > K:K </ output >
			--- ...</ T >
		--- =>
		--- < result > join(K:K) </ result >]
		--- : KSentence [metadata "computational rule"] .
	
	
endm