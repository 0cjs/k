mod IMP++-SEMANTICS0 is
  including CONFIG .
  including K-MAP-EXTRAS .
  including IMP++-SYNTAX0 .
  op `[_;_`] : Nat Nat -> KList .
  op env : -> CellLabel .
  op k : -> CellLabel .
  op nextLoc : -> CellLabel .
  op output : -> CellLabel .
  op restore : Map -> K .
  op result : -> CellLabel .
  op store : -> CellLabel .
  op thread : -> CellLabel .
  op thread* : -> CellLabel .
  op threads : -> CellLabel .
  eq <_>_</_>(T,__(Top:Set,<_>_</_>(output,Output:List,output),<_>_</_>(
    threads,.s,threads)),T)
    = <_>_</_>(result,Output:List,result) [metadata "keq"] .
  eq <_>_</_>(thread,__(Thread:Set,<_>_</_>(k,.k,k)),thread)
    = .s [metadata "keq"] .
  eq __(<_>_</_>(k,_~>_(restore(Env:Map),K:K),k),<_>_</_>(env,Env':Map,env))
    = __(<_>_</_>(k,K:K,k),<_>_</_>(env,Env:Map,env)) [metadata "keq"] .
  eq __(<_>_</_>(k,_~>_(vars_;_(Xl:KList,S:K),K:K),k),<_>_</_>(nextLoc,
    subsort"Int < KResult"_(N:Nat),nextLoc),<_>_</_>(env,Env:Map,env),<_>_</_>(
    store,Store:Map,store))
    = __(<_>_</_>(k,_~>_(_~>_(S:K,restore(Env:Map)),K:K),k),<_>_</_>(nextLoc,
    subsort"Int < KResult"_(_+Int_(N:Nat,length_(Xl:KList))),nextLoc),<_>_</_>(
    env,_`[_<-_`](Env:Map,Xl:KList,`[_;_`](N:Nat,_+Int_(N:Nat,length_(
    Xl:KList)))),env),<_>_</_>(store,__(Store:Map,m(`[_;_`](N:Nat,_+Int_(N:Nat,
    length_(Xl:KList))),subsort"Int < KResult"_(0))),store)) [metadata "keq"] .
  eq `[_;_`](N1:Nat,N2:Nat)
    = if_then_else_fi(_>=Int_(N1:Nat,N2:Nat),.kl,_`,_(subsort"Int < KResult"_(
    N1:Nat),`[_;_`](sNat_(N1:Nat),N2:Nat))) [metadata "keq"] .
  rl skip
    => .k [metadata "krl"] .
  rl <_>_</_>(k,_~>_(halt,K:K),k)
    => <_>_</_>(k,.k,k) [metadata "krl"] .
  rl <_>_</_>(k,_~>_(while_do_(B:K,S:K),K:K),k)
    => <_>_</_>(k,_~>_(if_then_else_(B:K,_;_(S:K,while_do_(B:K,S:K)),skip),
    K:K),k) [metadata "krl"] .
  rl <_>_</_>(thread,__(Thread:Set,<_>_</_>(k,_~>_(spawn_(S:K),K:K),k),
    <_>_</_>(env,Env:Map,env)),thread)
    => __(<_>_</_>(thread,__(<_>_</_>(k,S:K,k),<_>_</_>(env,Env:Map,env)),
    thread),<_>_</_>(thread,__(Thread:Set,<_>_</_>(k,K:K,k),<_>_</_>(env,
    Env:Map,env)),thread)) [metadata "krl"] .
  rl _+_(subsort"Int < KResult"_(I1:Int),subsort"Int < KResult"_(I2:Int))
    => subsort"Int < KResult"_(_+Int_(I1:Int,I2:Int)) [metadata "krl"] .
  rl _;_(S1:K,S2:K)
    => _~>_(S1:K,S2:K) [metadata "krl"] .
  rl _<=_(subsort"Int < KResult"_(I1:Int),subsort"Int < KResult"_(I2:Int))
    => subsort"Bool < KResult"_(_<=Int_(I1:Int,I2:Int)) [metadata "krl"] .
  rl __(<_>_</_>(k,_~>_(print_(subsort"Int < KResult"_(I:Int)),K:K),k),
    <_>_</_>(output,Output:List,output))
    => __(<_>_</_>(k,K:K,k),<_>_</_>(output,_`,_(Output:List,l(
    subsort"Int < KResult"_(I:Int))),output)) [metadata "krl"] .
  rl __(<_>_</_>(k,_~>_(++_(subsort"VarId < KProper"_(X:VarId)),K:K),k),
    <_>_</_>(env,__(Env:Map,m(subsort"VarId < KProper"_(X:VarId),
    subsort"Int < KResult"_(L:Int))),env),<_>_</_>(store,__(Store:Map,m(
    subsort"Int < KResult"_(L:Int),subsort"Int < KResult"_(I:Int))),store))
    => __(<_>_</_>(k,_~>_(subsort"Int < KResult"_(_+Int_(I:Int,1)),K:K),k),
    <_>_</_>(env,__(Env:Map,m(subsort"VarId < KProper"_(X:VarId),
    subsort"Int < KResult"_(L:Int))),env),<_>_</_>(store,__(Store:Map,m(
    subsort"Int < KResult"_(L:Int),subsort"Int < KResult"_(_+Int_(I:Int,1)))),
    store)) [metadata "krl"] .
  rl __(<_>_</_>(k,_~>_(_:=_(X:VarId,subsort"Int < KResult"_(I1:Int)),K:K),k),
    <_>_</_>(env,__(Env:Map,m(subsort"VarId < KProper"_(X:VarId),
    subsort"Int < KResult"_(L:Int))),env),<_>_</_>(store,__(Store:Map,m(
    subsort"Int < KResult"_(L:Int),subsort"Int < KResult"_(I2:Int))),store))
    => __(<_>_</_>(k,K:K,k),<_>_</_>(env,__(Env:Map,m(
    subsort"VarId < KProper"_(X:VarId),subsort"Int < KResult"_(L:Int))),env),
    <_>_</_>(store,__(Store:Map,m(subsort"Int < KResult"_(L:Int),
    subsort"Int < KResult"_(I1:Int))),store)) [metadata "krl"] .
  rl __(<_>_</_>(k,_~>_(subsort"VarId < KProper"_(X:VarId),K:K),k),<_>_</_>(
    env,__(Env:Map,m(subsort"VarId < KProper"_(X:VarId),
    subsort"Int < KResult"_(L:Int))),env),<_>_</_>(store,__(Store:Map,m(
    subsort"Int < KResult"_(L:Int),subsort"Int < KResult"_(I:Int))),store))
    => __(<_>_</_>(k,_~>_(subsort"Int < KResult"_(I:Int),K:K),k),<_>_</_>(env,
    __(Env:Map,m(subsort"VarId < KProper"_(X:VarId),subsort"Int < KResult"_(
    L:Int))),env),<_>_</_>(store,__(Store:Map,m(subsort"Int < KResult"_(L:Int),
    subsort"Int < KResult"_(I:Int))),store)) [metadata "krl"] .
  rl _and_(subsort"Bool < KResult"_(false),B:K)
    => subsort"Bool < KResult"_(false) [metadata "krl"] .
  rl _and_(subsort"Bool < KResult"_(true),B:K)
    => B:K [metadata "krl"] .
  rl if_then_else_(subsort"Bool < KResult"_(false),S1:K,S2:K)
    => S2:K [metadata "krl"] .
  rl if_then_else_(subsort"Bool < KResult"_(true),S1:K,S2:K)
    => S1:K [metadata "krl"] .
  rl not_(subsort"Bool < KResult"_(T:Bool))
    => subsort"Bool < KResult"_(notBool_(T:Bool)) [metadata "krl"] .
  crl _/_(subsort"Int < KResult"_(I1:Int),subsort"Int < KResult"_(I2:Int))
    => subsort"Int < KResult"_(_/Int_(I1:Int,I2:Int))
    if _=/=Bool_(I2:Int,0)= true [metadata "krl"] .
endm

