load ../../../k-prelude
mod SIMPLE-TYPED-SYNTAX is including PL-INT + PL-ID .
  sorts Exp Decl Stmt Stmts .
  subsorts Id Int Bool < Exp .
  subsort Decl Stmt < Stmts .
  sorts BasicType Type .
  subsort BasicType < Type .
  ops int bool void : -> BasicType .
  op _[] : BasicType -> Type .

--- List{Exp}
  sort List{Exp} .  subsort Exp < List{Exp} .
  op .List{Exp} : -> List{Exp} .
  op _,_ : List{Exp} List{Exp} -> List{Exp} [prec 70 assoc id: .List{Exp}] .
--- List{TypedId}
  sorts TypedId List{TypedId} .
  subsort TypedId < List{TypedId} .
  op .List{TypedId} : -> List{TypedId} .
  op __ : Type Id -> TypedId .
  op _,_ : List{TypedId} List{TypedId} -> List{TypedId} [prec 70 assoc id: .List{TypedId}] .

  op ++_ : Id -> Exp [prec 0] .
  op _+_ : Exp Exp -> Exp [gather(E e) prec 33 metadata "strict"] .
  op _-_ : Exp Exp -> Exp [gather(E e) prec 33 metadata "strict"] .
  op _*_ : Exp Exp -> Exp [gather(E e) prec 31 metadata "strict"] .
  op _/_ : Exp Exp -> Exp [gather(E e) prec 31 metadata "strict"] .
  op _%_ : Exp Exp -> Exp [gather(E e) prec 31 metadata "strict"] .
  op -_ : Exp -> Exp  [metadata "strict"] .
  op _<_ : Exp Exp -> Exp [prec 37 metadata "strict"] .
  op _<=_ : Exp Exp -> Exp [prec 37 metadata "strict"] .
  op _>_ : Exp Exp -> Exp [prec 37 metadata "strict"] .
  op _>=_ : Exp Exp -> Exp [prec 37 metadata "strict"] .
  op _==_ : Exp Exp -> Exp [prec 37 metadata "strict"] .
  op _!=_ : Exp Exp -> Exp [prec 37 metadata "strict"] .
  op _and_ : Exp Exp -> Exp [gather(E e) prec 55 metadata "strict"] .
  op _or_ : Exp Exp -> Exp [gather(E e) prec 59 metadata "strict"] .
  op not_ : Exp -> Exp [prec 53 metadata "strict"] .
  op _[_] : Id Exp -> Exp [prec 1 metadata "strict(2)"] .
  op read() : -> Exp .
  op _() : Id -> Exp .
  op _(_) : Id List{Exp} -> Exp [prec 0 metadata "strict"] .
  op __; : BasicType Id -> Decl [prec 0 gather(E E)] .
  op __[_]; : BasicType Id Nat -> Decl [prec 0] .
  op {} : -> Stmt .
  op {_} : Stmts -> Stmt .
  op __ : Stmts Stmts -> Stmts [prec 100 gather(e E)] .
  op write(_); : Exp -> Stmt [metadata "strict"] .
  op _=_; : Id Exp -> Stmt [prec 1 gather(e &) metadata "strict(2)"] .
  op _[_]=_; : Id Exp Exp -> Stmt [prec 0 gather(e & &) metadata "strict(2 3)"] .
  op if_then_else_ : Exp Stmt Stmt -> Stmt [metadata "strict(1)"] .
  op if_then_ : Exp Stmt -> Stmt .
  op while_do_ : Exp Stmt -> Stmt .
  op for_=_to_do_ : Id Exp Exp Stmt -> Stmt .
  op main : -> Id .
  op _; : Exp -> Stmt [prec 50 metadata "strict"] .
  op return_; : Exp -> Stmt [metadata "strict"] .
  op __()_ : Type Id Stmt -> Decl .
  op __(_)_ : Type Id List{TypedId} Stmt -> Decl .
endm
eof
mod SIMPLE-TYPED-DESUGARED-SYNTAX is including SIMPLE-TYPED-SYNTAX .

--- List{Id}
  sort List{Id} .  subsort Id < List{Id} .
  op _,_ : List{Id} List{Id} -> List{Id} [ditto] .

--- List{BasicType}
  sort List{BasicType} .  subsort BasicType < List{BasicType} .
  op .List{BasicType} : -> List{BasicType} .
  op _,_ : List{BasicType} List{BasicType} -> List{BasicType} [prec 70 assoc id: .List{BasicType}] .

  vars F X : Id .  vars Xl : List{Id} .  vars E E1 E2 : Exp .  vars S S' : Stmt .  var Tp : Type .  var TpXl : List{TypedId} .
  eq if E then S = if E then S else {} .
  eq for X = E1 to E2 do S = {int X ; X = E1 ; while X <= E2 do {S X = X + 1 ;}} .
  op lambda : BasicType List{BasicType} List{Id} Stmt -> Exp .
  eq Tp F() S = Tp F(.List{TypedId}) S .
  eq Tp F(TpXl) S = (typeList(TpXl) -> Tp) F ; F = lambda(Tp,typeList(TpXl),idList(TpXl),S) ; .
  op _() : Exp -> Exp .
  op _(_) : Exp List{Exp} -> Exp [prec 0 metadata "strict"] .
  eq E() = E(.List{Exp}) .
endm

q
