mod BF is
	including K-PROPER .
	including CONFIG .
	including K-MAP-EXTRAS .
	including K-RULES .
	including K-CONFIG .
	including PL-INT .
	including PL-STRING .
	including K .
--- Syntax
	op memory : -> CellLabel .
	op output : -> CellLabel .
	op result : -> CellLabel .
	op input : -> CellLabel .
	op k : -> CellLabel .

	--- comments from http://en.wikipedia.org/wiki/Brainfuck
	op Seq : -> KProperLabel [metadata "arity 2"] .
	op GoRight : -> KProperLabel [metadata "arity 0"] . --- increment the data pointer (to point to the next cell to the right).
	op GoLeft : -> KProperLabel [metadata "arity 0"] . --- decrement the data pointer (to point to the next cell to the left).
	op Increase : -> KProperLabel [metadata "arity 0"] . --- increment (increase by one) the byte at the data pointer.
	op Decrease : -> KProperLabel [metadata "arity 0"] . --- decrement (decrease by one) the byte at the data pointer.
	op Print : -> KProperLabel [metadata "arity 0"] . --- output the value of the byte at the data pointer.
	op Read : -> KProperLabel [metadata "arity 0"] . --- accept one byte of input, storing its value in the byte at the data pointer.
	op While : -> KProperLabel [metadata "arity 1"] .
	--- [ 	if the byte at the data pointer is zero, then instead of moving 
	---		the instruction pointer forward to the next command, jump it 
	---		forward to the command after the matching ] command*.
	--- ] 	if the byte at the data pointer is nonzero, then instead of moving 
	---		the instruction pointer forward to the next command, jump it back 
	---		to the command after the matching [ command*.
	
--- Programs
  	op helloWorld : -> KProperLabel [metadata "arity 0"] .
	eq helloWorld(.kl) = (
		Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( While( Seq( GoRight(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( GoRight(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( GoRight(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( GoRight(.kl) , Seq( Increase(.kl) , Seq( GoLeft(.kl) , Seq( GoLeft(.kl) , Seq( GoLeft(.kl) , Seq( GoLeft(.kl) , Seq( Decrease(.kl) , .k ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) , Seq( GoRight(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Print(.kl) , Seq( GoRight(.kl) , Seq( Increase(.kl) , Seq( Print(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Print(.kl) , Seq( Print(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Print(.kl) , Seq( GoRight(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Print(.kl) , Seq( GoLeft(.kl) , Seq( GoLeft(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Print(.kl) , Seq( GoRight(.kl) , Seq( Print(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Increase(.kl) , Seq( Print(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Print(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Decrease(.kl) , Seq( Print(.kl) , Seq( GoRight(.kl) , Seq( Increase(.kl) , Seq( Print(.kl) , Seq( GoRight(.kl) , Seq( Print(.kl) , .k ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )
	) .
	
--- Semantics
	op sentinel : -> KProperLabel .
	op eval : K -> Set .
	op inject : Int -> KResultLabel .
	op inject : String -> KResultLabel .
	
	mb configuration 
		< T >
			< k > K:K </ k >
			< memory > L:List </ memory >
			< output > K:K </ output >
			< input > L:List </ input >
		</ T >  
		< result > K:K </ result > 
		: KSentence .
	
	eq [Start]: eval(K:K) = 
		< T >
			< k > K:K </ k >
			< memory > l(sentinel(.kl)) </ memory >
			< output > inject("")(.kl) </ output >
			< input > .l </ input >
		</ T > .

	mb [Finish]: rule [
		< T > S:Set < k > .k </ k > < output > K:K </ output > </ T > 
			=> < result > K:K </ result >
		] : KSentence [metadata "structural"] .
		
	mb rule
		< memory > [l(sentinel(.kl)) => l(inject(0)(.kl)), l(sentinel(.kl))], L:List </ memory > 
		: KSentence [metadata "structural"] .
		
	mb [Sequence]: rule
		[Seq(K1:K, K2:K) => K1:K ~> K2:K]
		: KSentence [metadata "structural"] .
		
	mb [Increase]: rule 
		< k > [Increase(.kl) => .k] ~> KCxt:K </ k >
		--- < memory > l([inject(I:Int)(.kl) => inject(sNat(I:Int))(.kl)]), L:List </ memory > --- doesn't work
		--- < memory > l([inject(I:Int)(.kl) => .k]), L:List </ memory >  --- works
		< memory > l([inject(I:Int)(.kl) => (inject(I:Int +Int 1))(.kl)]), L:List </ memory > 
		: KSentence [metadata "structural"] .
	mb [Decrease]: rule 
		< k > [Decrease(.kl) => .k] ~> KCxt:K </ k >
		< memory > l([inject(I:Int)(.kl) => (inject(I:Int -Int 1))(.kl)]), L:List </ memory > 
		: KSentence [metadata "structural"] .
	
	mb [WhileNZ-NZ]: rule 
		< k > [While(K:K) => K:K ~> While(K:K)] ~> KCxt:K </ k > 
		< memory > l(inject(I:Int)(.kl)), L:List </ memory > 
		if (I:Int =/=Bool 0) 
		: KSentence [metadata "structural"] .
	mb [WhileNZ-Z]: rule 
		< k > [While(K:K) => .k] ~> KCxt:K </ k >
		< memory > l(inject(0)(.kl)), L:List </ memory > 
		: KSentence [metadata "structural"] .
		
	mb [GoRight]: rule 
		< k > [GoRight(.kl) => .k] ~> KCxt:K </ k > 
		< memory > [Li:ListItem, L:List => L:List, Li:ListItem] </ memory > 
		: KSentence [metadata "structural"] .
	mb [GoLeft]: rule 
		< k > [GoLeft(.kl) => .k] ~> KCxt:K </ k > 
		< memory > [L:List, Li:ListItem => Li:ListItem, L:List] </ memory > 
		: KSentence [metadata "structural"] .
		
	mb [Output]: rule 
		< k > [Print(.kl) => .k] ~> KCxt:K </ k > 
		< memory > l(inject(I:Int)(.kl)), L:List </ memory > 
		< output > inject([S:String => S:String +String charString(absInt(I:Int))])(.kl) </ output > 
		: KSentence [metadata "structural"] .

endm

---rew eval(helloWorld(.kl)) .
