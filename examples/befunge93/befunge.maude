load ../../k-prelude
mod BEFUNGE is
	including K-PROPER .
	including CONFIG .
	including K-MAP-EXTRAS .
	including K-RULES .
	including K-CONFIG .
	including PL-INT .
	including PL-STRING .
	
	including K-OPEN-CELLS .
	---including K-WRAPPERS-LABELS . --- can't include this?
	
	including K .
--- Syntax
	---- Comments from Chris Pressey, http://catseye.tc/projects/befunge93/doc/befunge93.html
	--- COMMAND         INITIAL STACK (bot->top)	RESULT (STACK)
	----        		 -------------           -----------------
	--- + (add)         <value1> <value2>       <value1 + value2>
	op add : -> KProperLabel [metadata "arity 0"] .
	--- - (subtract)    <value1> <value2>       <value1 - value2>
	op subtract : -> KProperLabel [metadata "arity 0"] .
	--- / (divide)      <value1> <value2>       <value1 / value2> (nb. integer)
	op divide : -> KProperLabel [metadata "arity 0"] .
	--- * (multiply)    <value1> <value2>       <value1 * value2>
	op multiply : -> KProperLabel [metadata "arity 0"] .
	--- % (modulo)      <value1> <value2>       <value1 mod value2>
	op modulo : -> KProperLabel [metadata "arity 0"] .
	
	--- ! (not)         <value>                 <0 if value non-zero, 1 otherwise>
	op not : -> KProperLabel [metadata "arity 0"] .
	--- ` (greater)     <value1> <value2>       <1 if value1 > value2, 0 otherwise>
	op greater : -> KProperLabel [metadata "arity 0"] .
	
	--- > (right)                               PC -> right
	op right : -> KProperLabel [metadata "arity 0"] .
	--- < (left)                                PC -> left
	op left : -> KProperLabel [metadata "arity 0"] .
	--- ^ (up)                                  PC -> up
	op up : -> KProperLabel [metadata "arity 0"] .
	--- v (down)                                PC -> down
	op down : -> KProperLabel [metadata "arity 0"] .
	--- ? (random)                              PC -> right? left? up? down? ???
	op random : -> KProperLabel [metadata "arity 0"] .
	
	--- _ (horizontal if) <boolean value>       PC->left if <value>, else PC->right
	op horizontalIf : -> KProperLabel [metadata "arity 0"] .
	--- | (vertical if)   <boolean value>       PC->up if <value>, else PC->down
	op verticalIf : -> KProperLabel [metadata "arity 0"] .
	
	--- " (stringmode)                          Toggles 'stringmode'
	op stringmode : -> KProperLabel [metadata "arity 0"] .
	
	--- : (dup)         <value>                 <value> <value>
	op dup : -> KProperLabel [metadata "arity 0"] .
	--- # (bridge)                              'jumps' PC one farther; skips over next command
	op bridge : -> KProperLabel [metadata "arity 0"] .
	
	--- \ (swap)        <value1> <value2>       <value2> <value1>
	op swap : -> KProperLabel [metadata "arity 0"] .
	--- $ (pop)         <value>                 pops <value> but does nothing
	op pop : -> KProperLabel [metadata "arity 0"] .
	
	--- . (output value)	<value>             outputs <value> as integer
	op printNumber : -> KProperLabel [metadata "arity 0"] .
	--- , (output character)	<value>         outputs <value> as ASCII
	op printCharacter : -> KProperLabel [metadata "arity 0"] .
	--- & (input value)                         <value user entered>
	op readNumber : -> KProperLabel [metadata "arity 0"] .
	--- ~ (input character)                     <character user entered>
	op readCharacter : -> KProperLabel [metadata "arity 0"] .
	
	--- @ (end)                                 ends program
	op end : -> KProperLabel [metadata "arity 0"] .
	
	--- g (get)         <x> <y>                 <value at (x,y)>
	op metaGet : -> KProperLabel [metadata "arity 0"] .
	--- p (put)         <value> <x> <y>         puts <value> at (x,y)
	op metaPut : -> KProperLabel [metadata "arity 0"] .
	
	
	--- [space] (nop)
	op nop : -> KProperLabel [metadata "arity 0"] .
	op err : -> KProperLabel [metadata "arity 0"] .
	
	--- [all commands] (push)
	op command : -> KProperLabel [metadata "arity 2"] . --- necessary to handle stringmode
	op push : -> KProperLabel [metadata "arity 1"] .
	---------
	--- e.g.:
	--- command('$', pop(.kl))
	--- command(' ', nop(.kl))
	--- command('x', err(.kl))
	--- command('4', push(inject(4)(.kl))
	
--- Configuration
	op stack : -> CellLabel .
	op direction : -> CellLabel .
	op mode : -> CellLabel .
	op program : -> CellLabel .
	op pc : -> CellLabel .
	op output : -> CellLabel .
	op input : -> CellLabel .
	op k : -> CellLabel .
	op result : -> CellLabel .
	
--- Semantics
	op eval : K -> Set .
	op eval : K K -> Set .
	op inject : Int -> KLabel .
	op inject : Char -> KLabel .
	op inject : String -> KLabel .
	op injectM : Map -> KLabel .
	
	op coord : -> KLabel .
	op load : -> KLabel .
	op defaultmode : -> KLabel .
	op movePC : -> KLabel .
	
	mb configuration 
		< T >
			< k > K:K </ k >
			< stack > L:List </ stack >
			< direction > K:K </ direction >
			< pc > K:K </ pc >
			< mode > K:K </ mode >
			< program > M:Map </ program >
			< output > K:K </ output >
			< input > K:K </ input >
		</ T >  
		< result > K:K </ result > 
		: KSentence .
	
	eq [Start]: eval(injectM(M:Map)(.kl)) =
		< T >
			< k > .k </ k >
			< stack > .l </ stack >
			< direction > right(.kl) </ direction >
			< pc > coord(inject(0)(.kl), inject(0)(.kl)) </ pc >
			< mode > defaultmode(.kl) </ mode >
			< program > M:Map </ program >
			< output > inject("")(.kl) </ output >
			< input > .k </ input >
		</ T > .
		
	mb [Finish]: rule [
		< T > S:Set < k > end(.kl) ...</ k > < output > K:K </ output > </ T > 
			=> < result > K:K </ result >
		] : KSentence [metadata "structural"] .
		
	---------------------------
	---- very structural
	
	mb [Next]: rule
		< k > [.k => load(.kl) ~> movePC(.kl)] </ k >
		: KSentence [metadata "structural"] .
	
	mb [Load]: rule
		< k > [load(.kl) => K:K] ...</ k >
		< pc > Loc:K </ pc >
		< program >... Loc:K |-> K:K ...</ program >
		: KSentence [metadata "structural"] .
	
	mb [MovePC-right]: rule 
		< k > [movePC(.kl) => .k] ...</ k >
		< direction > right(.kl) </ direction >
		< pc > coord(inject([I:Int => (I:Int +Int 1) %Int 80])(.kl), K:K) </ pc >
		: KSentence [metadata "structural"] .
	mb [MovePC-left]: rule 
		< k > [movePC(.kl) => .k] ...</ k >
		< direction > left(.kl) </ direction >
		< pc > coord(inject([I:Int => ((I:Int -Int 1) +Int 80) %Int 80])(.kl), K:K) </ pc >
		: KSentence [metadata "structural"] .
	mb [MovePC-up]: rule 
		< k > [movePC(.kl) => .k] ...</ k >
		< direction > up(.kl) </ direction >
		< pc > coord(K:K, inject([I:Int => ((I:Int -Int 1) +Int 25) %Int 25])(.kl)) </ pc >
		: KSentence [metadata "structural"] .
	mb [MovePC-down]: rule 
		< k > [movePC(.kl) => .k] ...</ k >
		< direction > down(.kl) </ direction >
		< pc > coord(K:K, inject([I:Int => (I:Int +Int 1) %Int 25])(.kl)) </ pc >
		: KSentence [metadata "structural"] .
		
	mb [InterpretCommand-default]: rule
		< k > [command(K1:K, K2:K) => K2:K] ...</ k >
		< mode > defaultmode(.kl) </ mode >
		: KSentence [metadata "structural"] .
	mb [InterpretCommand-string-notmode]: rule
		< k > [command(K1:K, K2:K) => push(charToAscii(K1:K))] ...</ k >
		< mode > stringmode(.kl) </ mode >
		if (K2:K =/=Bool stringmode(.kl))
		: KSentence [metadata "structural"] .
	mb [InterpretCommand-string-mode]: rule
		< k > [command(K1:K, stringmode(.kl)) => stringmode(.kl)] ...</ k >
		: KSentence [metadata "structural"] .
		
	---op asAscii : -> KLabel .
	---eq asAscii(inject(S:String)(.kl)) = inject(asciiString(S:String))(.kl) .
		
	op charToAscii : -> KProperLabel [metadata "arity 1"] .
	
	mb [charToAscii]: rule
		[charToAscii(inject(C:Char)(.kl)) => inject(asciiString(C:Char))(.kl)]
		: KSentence [metadata "structural"] .
	---- end structural
	---------------------------

	mb [stringmode-on]: rule
		< k > [stringmode(.kl) => .k] ...</ k >
		< mode > [defaultmode(.kl) => stringmode(.kl)] </ mode >
		: KSentence [metadata "computational rule"] .
	mb [stringmode-off]: rule
		< k > [stringmode(.kl) => .k] ...</ k >
		< mode > [stringmode(.kl) => defaultmode(.kl)] </ mode >
		: KSentence [metadata "computational rule"] .
		
	mb [push]: rule
		< k > [push(K:K) => .k] ...</ k >
		< stack > [.l => l(K:K)] ...</ stack >
		: KSentence [metadata "computational rule"] .
		
endm