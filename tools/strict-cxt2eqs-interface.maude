load make-strict
load printing

fmod K-ATTRS is 
  including SYNTAX-ATTRS .
  including STRICT-ATTRS .
  including CONFIGURATION-ATTRS .
endfm


fmod PARSE-METADATA-BASIC  is
  including CONVERSION .
  including META-MODULE .
  including STRING-EXTRAS .

  sorts AttrStringPair .
  op {_,_} : AttrSet String -> AttrStringPair .

  var S : String .
  op metadataParse : String -> AttrSet .
  eq metadataParse(S) = metadataStrippedParse(stripSpaces(S)) .
  op metadataStrippedParse : String -> AttrSet .
  eq metadataStrippedParse("") = none .
endfm

fmod PARSE-METADATA-SYNTAX is
  including PARSE-METADATA-BASIC .
  including SYNTAX-ATTRS .
  var S S' S1 : String . var F : FindResult .  var Q : Qid .
  var N : Nat .  var AS : AttrSet .
  ceq metadataStrippedParse(S) = kaux  metadataParse(stripSpaces(S'))
   if "aux" = substr(S,0,length("aux")) 
   /\ S' := (substr(S,length("aux"),length(S))) 
   /\ S' == "" or-else substr(S',0,1) == " " .
  ceq metadataStrippedParse(S) = kdisolve metadataParse(stripSpaces(S'))
   if "disolve" = substr(S,0,length("disolve")) 
   /\ S' := (substr(S,length("disolve"),length(S))) 
   /\ S' == "" or-else substr(S',0,1) == " " .
  ceq metadataStrippedParse(S) = ksyntax metadataParse(stripSpaces(S'))
   if "syntax" = substr(S,0,length("syntax")) 
   /\ S' := (substr(S,length("syntax"),length(S))) 
   /\ S' == "" or-else substr(S',0,1) == " " .
 ceq metadataStrippedParse(S) = krenameTo(Q) metadataParse(S')
   if "renameTo " = substr(S,0,length("renameTo ")) 
   /\ S1 := stripSpaces(substr(S,length("renameTo "),length(S))) 
   /\ F :=   find(S1," ", 0)
   /\ Q := qid(if (F == notFound) then  S1 else substr(S1, 0,F) fi)
   /\ S' := if (F == notFound) then "" 
            else stripSpaces(substr(S1, find(S1," ",0),length(S1))) fi .
  ceq metadataStrippedParse(S) = kcolor(Q) metadataParse(S1) 
   if "color:" == substr(S,0,length("color:")) 
   /\ S' := stripSpaces(substr(S,length("color:"), length(S))) + " " 
   /\ N := find(S', " ", 0)
   /\ Q := qid(substr(S', 0, N))
   /\ S1 := substr(S', N, length(S')) .
  ceq metadataStrippedParse(S) = klatex(AS) metadataParse(S')
   if  "latex" = substr(S,0,length("latex")) 
   /\ {AS, S'} := latexParse(stripSpaces(substr(S, length("latex"), length(S))))  .

  op latexParse : String -> AttrStringPair .
  ceq latexParse(S) 
    = {metadataParse(substr(S,1,N)), substr(S, N + 2, length(S))}
   if "(" = substr(S, 0, 1)
   /\ s(N) := find(S, ")", 0)  .
endfm

fmod PARSE-METADATA-STRICT is
  including PARSE-METADATA-BASIC .
  including STRICT-ATTRS .
  var Q : Qid . var AS : AttrSet . var Nl : NatList .
  var A : Attr . var S S' S1 : String . var F : FindResult .
 ceq metadataStrippedParse(S) = karity(N) metadataParse(S')
   if "arity " = substr(S,0,length("arity ")) 
   /\ S1 := stripSpaces(substr(S,length("arity "),length(S))) 
   /\ F :=   find(S1," ", 0)
   /\ N := rat(if (F == notFound) then  S1 else substr(S1, 0,F) fi,10)
   /\ S' := if (F == notFound) then "" 
            else stripSpaces(substr(S1, find(S1," ",0),length(S1))) fi .
  ceq metadataStrippedParse(S) = A metadataParse(S')
   if  "strict" = substr(S,0,length("strict")) 
   /\ {A, S'} := strictParse(stripSpaces(substr(S, length("strict"), length(S))))  .
  ceq metadataStrippedParse(S) = conv2SeqStrict(A) metadataParse(S')
   if  "seqstrict" = substr(S,0,length("seqstrict")) 
   /\ {A, S'} := strictParse(stripSpaces(substr(S, length("seqstrict"), length(S)))) .
  ops conv2SeqStrict : Attr -> Attr .
  eq conv2SeqStrict(kstrict(Nl)) = seqkstrict(Nl) .
---  eq conv2SeqStrict(vstrict(Ql)) = seqvstrict(Ql) .

  op strictParse : String -> AttrStringPair .
  var N : Nat . var Ql : QidList .
  ceq strictParse(S) 
    = {strictListParse(tokenize(stripSpaces(substr(S,1,N)))), substr(S, N + 2, length(S))}
   if "(" = substr(S, 0, 1)
   /\ s(N) := find(S, ")", 0)  .
  eq strictParse(S) = {kstrict(nil), S} [owise] .

  op strictListParse : QidList -> Attr .
  ceq strictListParse(Q Ql) = kstrict(parseNatList(Q Ql)) 
   if (rat(string(Q),10) :: Nat) .
  eq strictListParse(Ql) = none [owise print "error parsing strict arguments" Ql] .
---     else vstrict(Q Ql) fi .

  op parseNatList : QidList -> [NatList] .
  eq parseNatList(Q Ql) = rat(string(Q), 10) parseNatList(Ql) .
  eq parseNatList(nil) = nil .

endfm

fmod PARSE-METADATA-CONFIGURATION is
  including PARSE-METADATA-BASIC .
  including CONFIGURATION-ATTRS .
  var S S' S1 : String . var F : FindResult .  var Q : Qid .  var N : Nat .
  ceq metadataStrippedParse(S) = kwrapping(Q) metadataParse(S1) 
   if "wrapping " == substr(S,0,length("wrapping ")) 
   /\ S' := stripSpaces(substr(S,length("wrapping "), length(S))) + " " 
   /\ N := find(S', " ", 0)
   /\ Q := qid(substr(S', 0, N))
   /\ S1 := substr(S', N, length(S')) .
endfm

fmod PARSE-METADATA is
  including PARSE-METADATA-STRICT .
  including PARSE-METADATA-CONFIGURATION .
  including PARSE-METADATA-SYNTAX .
endfm
---(
red metadataParse("") .
red metadataParse("strict") .
red metadataParse("strict(1)") .
red metadataParse("strict(1 3 2)") .
red metadataParse("  strict   (  1  3  2   )   ") .
red metadataParse("strict(1 3 2)") .
red metadataParse("strict(ala bala portocala)") .
red metadataParse("aux") .
red metadataParse("strict seqstrict(1) strict(1 3 2) seqstrict  seqstrict   (  1  3  2   )   ") .
red metadataParse("strict seqstrict(1)   seqstrict   (  1  3  2   )   ") .
red metadataParse("disolve renameTo _ana") .
red metadataParse("strict disolve renameTo _are") .
red metadataParse("renameTo mere_ strict(1) disolve") .
red metadataParse("  strict   (  1  3  2   )   ") .
red metadataParse("strict renameTo _gina_ disolve seqstrict(1) strict(1 3 2) seqstrict  seqstrict   (  1  3  2   )   ") .
red metadataParse("strict seqstrict(1) renameTo _are_   seqstrict   (  1  3  2   )   ") .
red metadataParse("strict seqstrict(1) renameTo _are_   disolve seqstrict   (  1  3  2   )   ") .
red metadataParse("strict seqstrict(1) arity 5 renameTo _are_  arity 9 disolve wrapping K seqstrict   (  1  3  2   )   ") .
red metadataParse("wrapping Set`{ConfigItem`}") .
red metadataParse("latex ( color: red wrapping Me)") .
q
---)

mod STRICT-METADATA-INTERFACE is
  including STRICTOPS2CXT .
  including PARSE-METADATA .
  var Q : Qid . var AS : AttrSet . var Str : String .
  eq strictOps2cxtOp(op Q : nil -> 'KProperLabel [AS metadata(Str)] .)
   = strictOps2cxtOp(op Q : nil -> 'KProperLabel [AS metadataParse(Str)] .) .
endm

mod STRICTOPS2CXT-INTERFACE is
  including STRICTOPS2CXT .
  including  STRICT-METADATA-INTERFACE .
  including META-LEVEL .
  var Syntax CxtStrict : String .
  var QSyntax QCxtStrict : Qid .
  op strictOps2cxt : String String ~> Module .
  eq strictOps2cxt(Syntax, CxtStrict) = strictOps2cxt(qid(Syntax), qid(CxtStrict)) .
  op strictOps2cxt : Qid Qid ~> Module .
  eq strictOps2cxt(QSyntax,QCxtStrict) = strictOps2cxt(QCxtStrict, upModule(QSyntax, true)) .

endm

mod STRICTCXT2EQ-INTERFACE is
  including STRICTCXT2EQ .
  including META-LEVEL .
   op strictCxt2eq : String String String ~> Module .
   var Syntax StrictCxt StrictEq : String .
   eq strictCxt2eq(Syntax, StrictCxt, StrictEq) = strictCxt2eq(qid(Syntax), qid(StrictEq), upModule(qid(StrictCxt),false)) .
endm

mod STRICTOPS2EQ-INTERFACE is
  including STRICTOPS2EQ .
  including  STRICT-METADATA-INTERFACE .
  including META-LEVEL .
  op strictOps2eq : String String ~> Module .
  var Syntax StrictEq : String .
  eq strictOps2eq(Syntax, StrictEq)
   = strictOps2eq(qid(StrictEq), upModule(qid(Syntax),true)) .
endm

mod MAKE-STRICT-INTERFACE is 
  including LOOP-MODE + META-LEVEL .
  including MODULE-META-PRETTY-PRINT .
  op make-strict : -> System .
  op idle : -> State .
  var Q Syntax StrictCxt StrictEq : Qid . var QIL QIL' : QidList . var FM : Module .
  eq make-strict = [nil, idle, 
 'Usage: 'strictOps2cxt '<Name> '. 'or 'strictOps2eq '<Name> '.] .

  op wrapper : Qid -> Module .
  eq wrapper(Q) = (mod 'MKKS is including Q . 
                    sorts none . none none none none none endm) .
  op error : -> [Module] .
  op print : Module [Module] -> QidList .
  var Str : String . var M FM' : Module . var OPDS : OpDeclSet .  
  eq print(M,FM) = eMetaPrettyPrint(setRls(setEqs(FM,none),none), FM) [owise] .
  crl ['strictOps2cxt Syntax StrictCxt QIL, idle, QIL'] 
   => [QIL, idle, print(upModule(Syntax,false), FM )] 
   if FM := downTerm(getTerm(
             metaReduce(wrapper('STRICTOPS2CXT-INTERFACE),
                        'strictOps2cxt[upTerm(string(Syntax)),upTerm(string(StrictCxt))])),error) .
  crl ['strictOps2eq Syntax StrictEq QIL, idle, QIL'] 
   => [QIL, idle, print(upModule(Syntax,false), FM )] 
   if FM := downTerm(getTerm(
             metaReduce(wrapper('STRICTOPS2EQ-INTERFACE),
                        'strictOps2eq[upTerm(string(Syntax)),upTerm(string(StrictEq))])),error) .
endm
