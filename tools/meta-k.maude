fmod K-SORTS is including QID .
  
  op kSentenceSort : -> Qid .
  eq kSentenceSort = 'KSentence .
endfm

fmod K-META-OPS is including META-TERM .
  op nilKList : -> Qid .
  eq nilKList = '.kl.KList .

  op nilK : -> Qid .
  eq nilK = '.k.EmptyK .

  op kra_ : TermList -> Term .
  eq kra(Trl1,'_~>_[Trl],Trl2) = kra(Trl1,Trl,Trl2) .
  eq kra(empty) = nilK .
  eq kra(T) = T [owise] .
  eq kra(Trl) = '_~>_[Trl] [owise] .
 
  op klabel : -> Constant .
  eq klabel = 'k.CellLabel .
 
  var T : Term .  var Trl Trl1 Trl2 : TermList . 

  op kcell : Term -> Term .
  eq kcell(T) = '<_>_</_>[klabel,T,klabel] .
  
  op kWrap : Term -> Term .
  eq kWrap(T) = kcell(kra(T,'Rest:K)) .
--- replace the line above with the one below to get unrestricted strictness
---  eq kWrap(T) = T .


  op kList : TermList -> Term .
  eq kList(T) = T .
  eq kList(empty) = nilKList .
  eq kList(Trl) = '_`,_[Trl] [owise] .

  op wrapKList : Term -> Term .
  eq wrapKList(T) = '~[T] .

  op kApply : Term TermList -> Term .
  eq kApply(T, Trl) = '_`(_`)[T,kList(Trl)] .
endfm

fmod META-K-MODULE is
  including META-MODULE .
 var S : Sort .  var T : Type .

  ops EmptyK KProper KResult NeK K KLabel KProperLabel KResultLabel : -> Sort .
  ops EmptyKList ProperList NeProperList ResultList NeResultList NeKList KList : -> Sort .
  eq EmptyK = 'EmptyK .  eq KProper = 'KProper .  eq KResult = 'KResult .
  eq NeK = 'NeK .  eq K = 'K .
  eq KProperLabel = 'KProperLabel .  eq KResultLabel = 'KResultLabel .
  eq EmptyKList = 'EmptyKList .  eq ProperList = 'ProperList .  eq ResultList = 'ResultList .  eq NeProperList = 'NeProperList .  eq NeResultList = 'NeResultList .  eq KList = 'KList .  eq NeKList = 'NeKList .
  op ksorts : -> SortSet [memo] .
  eq ksorts = EmptyK ; KProper ; KResult ; NeK ; K .

  op klistSorts : -> SortSet [memo] .
  eq klistSorts = EmptyKList ; ProperList ; NeProperList ; ResultList ; NeResultList ; NeKList ; KList .

  op isKSort : Type -> Bool [memo] .
  eq isKSort(T) = T in ksorts .

  op isKListSort : Type -> Bool [memo] .
  eq isKListSort(T) = T in klistSorts .

  op ksubsorts : -> SubsortDeclSet [memo] .
  eq ksubsorts = (
    subsort EmptyK < K .
    subsort KProper < NeK .
    subsort KResult < NeK .
    subsort NeK < K .
    ) .

  op kops : -> OpDeclSet [memo] .
  eq kops = (
    op '.k : nil -> EmptyK [none] .
    op '_`(_`) : KLabel KList -> NeK [none] .
    op '_`(_`) : KProperLabel KList -> KProper [none] .
    op '_`(_`) : KResultLabel KList -> KResult [none] .
    op '_~>_ : K K -> K [none] .
  ) .

 op makeKLabel : Sort -> Sort .
 ceq makeKLabel(S) = KResultLabel if S = KResult .
 ceq makeKLabel(S) = KProperLabel if S = KProper .
 eq makeKLabel(S) = KLabel [owise] .
endfm

fmod META-K-RULES is including K-SORTS .
  including META-MODULE .
  var Q : Qid . var T : Term . var S : Type . var C : Condition .
  var AS : AttrSet .  var RK : KRuleKind .
  sort KRuleKind .
  ops keq krl knd : -> KRuleKind .
  op error : Qid -> [KRuleKind] .
  
  ops symbol_ : KRuleKind -> Qid .
  eq symbol keq = 'keq_ .  eq symbol krl = 'krl_ .  eq symbol knd = 'knd_ .

  op replaceS : -> Qid .
  eq replaceS = '`[`[_==>_`]`] .

  op getKRuleKind : Qid ~> KRuleKind . 
  eq getKRuleKind(Q) = if Q == symbol keq then keq else if Q == symbol krl then krl else if Q == symbol knd then knd else error(Q) fi fi fi .

  sort KRuleSplit .
  op {_,_,_,_} : KRuleKind Term Condition AttrSet -> KRuleSplit .

  
  op splitKRule : MembAx ~> KRuleSplit .
 ceq splitKRule((mb Q[T] : S [AS] .))
   = {getKRuleKind(Q),T,nil,AS} if S := kSentenceSort . 
 ceq splitKRule((cmb Q[T] : S if C [AS] .))
   = {getKRuleKind(Q),T,C,AS} if S := kSentenceSort . 

  op plugKRule : KRuleSplit ~> MembAx .
  eq plugKRule({RK,T,nil,AS}) = (mb symbol(RK)[T] : kSentenceSort [AS] .) .
  eq plugKRule({RK,T,C,AS}) = (cmb symbol(RK)[T] : kSentenceSort if C [AS] .) [owise] .
endfm


fmod K-META-CONFIG is including META-K-RULES .
  including INT .
  var Label Label' : Constant . var Contents Contents' T : Term .
  var Q Q' : Qid .  var B : Bool . var E : Ellipses .  var M : Module .  
  var AS : AttrSet .  var MAS : MembAxSet .

  op extractConfTerm : Module ~> Term .
  eq extractConfTerm(M) = extractConfTerm(getMbs(M)) .
  op extractConfTerm : MembAxSet ~> Term .
  eq extractConfTerm((mb 'kconf_[T] : 'KSentence [AS] .) MAS) = T .

  op removeConfTerm : MembAxSet -> MembAxSet .
  eq removeConfTerm((mb 'kconf_[T] : 'KSentence [AS] .) MAS) = MAS .
  eq removeConfTerm(MAS) = MAS [owise] .
  
  sort Ellipses .
  ops left right both none : -> Ellipses .
  op error : -> [Ellipses] .
  op symbol_ : Ellipses -> Qid .
  eq symbol none = '<_>_</_> .
  eq symbol left = '<_>..._</_> .
  eq symbol right = '<_>_...</_> .
  eq symbol both = '<_>..._...</_> .

  sort SplitCell .
  op {_,_,_,_} : Qid Term Bool Ellipses -> SplitCell .

  op splitKCell : Term ~> SplitCell .
  eq splitKCell(Q[Label,Contents,Label]) = {getCellName(getName(Label)), Contents,getCellMultiplicity(getName(Label)), getEllipses(Q)} .

  op getEllipses : Qid -> Ellipses .
  eq getEllipses(Q) = if (Q == symbol none) then none else if (Q == symbol left) then left else if (Q == symbol right) then right else if (Q == symbol both) then both else error fi fi fi fi .

  op getCellName : Qid -> Qid .
  eq getCellName(Q) = if getCellMultiplicity(Q) then 
   qid(substr(string(Q), 0, _-_(length(string(Q)),1))) else Q fi .
  op getCellMultiplicity : Qid -> Bool .
  eq getCellMultiplicity(Q) 
   = substr(string(Q), _-_(length(string(Q)), 1), 1) == "*" .


  op getName : SplitCell -> Qid .
  eq getName({Q,Contents,B,E}) = Q .
  op setName : SplitCell Qid -> SplitCell .
  eq setName({Q,Contents,B,E},Q') = {Q',Contents,B,E} .

  op getContents : SplitCell -> Term .
  eq getContents({Q,Contents,B,E}) = Contents .
  op setContents : SplitCell Term -> SplitCell .
  eq setContents({Q,Contents,B,E}, Contents') = {Q,Contents',B,E} .

  op getMultiplicity : SplitCell -> Bool .
  eq getMultiplicity({Q,Contents,B,E}) = B .

  op plugCell : SplitCell -> Term .
  eq plugCell({Q,Contents,B,E}) = symbol E[cellLabel(Q,B),Contents,cellLabel(Q,B)] .

  op mkCell : Qid Term -> Term .
  eq mkCell(Q,Contents) = plugCell({Q,Contents,false,none}) .

  op cellLabel : Qid Bool -> Constant .
  eq cellLabel(Q,B) = qid(string(Q) + if B then "*" else "" fi + ".CellLabel") .

  op sortSet : -> Sort .
  eq sortSet = 'Set .

  op emptySet : -> Constant .
  eq emptySet = '.s.Set .

  op ctorSet : -> Qid .
  eq ctorSet = '__ .
endfm

fmod META-ANONYMOUS-VARIABLE is
  including META-TERM .
  including CONVERSION .
  var T : Type . var N : Nat .

  op anyVarS : -> Qid .
  eq anyVarS = 'AnyVar .

  op anyVar : Type -> Variable .
  eq anyVar(T) = qid(string(anyVarS) + ":" + string(T)) .

  op anyVar : Nat Type -> Variable .
  eq anyVar(N, T) = qid(string(anyVarS) + string(N,10) + ":" + string(T)) .
endfm

fmod META-K-WRAPPERS is
  including META-LEVEL .
  op builtin-wrappers : -> OpDeclSet [memo] .
  eq builtin-wrappers = getOps(upModule('K-WRAPPERS, false)) .
endfm
