load prelude-extras
load meta-k

fmod LISTS-TO-K is
 including META-TERM-EXTRAS .
 including META-MODULE-EXTRAS .
 including META-LEVEL-EXTRAS .
 including META-K-MODULE .
 including META-K-RULES .
 including K-META-LISTS .
 including METADATA-EXTRAS .
 including CONVERSION .

--------------------------------------------------------------------------------
--- What needs to be done:
--------------------------
--- - Identify Lists sorts as non-standard sorts having K/KResult as a subsort- 
---   - remove sorts and their subsort declarations 
--- - associate to each sort its constructor and identity----------------------
---   - remove constructor and identity
---   - declare a new (KResult)Label associated to the list constructor
--- - find all ops that have result K and contain a list sort in arity
---   - change that sort to K and update strictness (if needed)
--- - find all other ops that have a list sort in their declaration
---   - change the list sort to KList
--- - Update all terms (mb, eq, rl) to be consistent with above declaration----
---   - if list sort under op of result sort K then add a wrapper--------------
---   - process list terms by replacing ctor by ',,' and id by '.kl'-----------
---   - rename constant and variables of the list sort-------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

 var Q Q' : Qid . var T T' T'' : Type . var Tl Tl' : TypeList . 
 var N : Nat .
 var MS : ModuleSet .  var M Flat : Module .
 vars Mbs : MembAxSet . var Mb : MembAx .
 var Eqs : EquationSet . var Eq : Equation .
 var Rls : RuleSet . var Rl : Rule .
 var Trms : TermList . vars T1 T2 Trm Trm' : Term .  var Cond : Condition .
 var C : Constant . var V : Variable .
 vars OPDS OPDS' Ops : OpDeclSet . var Op Op' : OpDecl .
 var SSDS : SubsortDeclSet . var SSD : SubsortDecl .
 var AS AS' : AttrSet .
 var CTORS : CTORSMap .

 op lists2kImports : ModuleSet ~> ImportList .
 eq lists2kImports(M MS) = lists2kImports(MS, getName(M), pseudoKSupersorts(getSubsorts(M))) .

 op lists2kImports : ModuleSet Qid SubsortDeclSet ~> ImportList .
 eq lists2kImports(MS, Q, SSDS) 
  = if SSDS == none
    then lists2kImports(MS)
    else lists2kImports(MS) (including Q .) 
    fi [print Q "(" SSDS ")" ] .
 eq lists2kImports(empty) = nil .

 op makeLists2k : Qid Module Module ModuleSet ~> Module .
 eq makeLists2k(Q, M, Flat, MS)
  = makeLists2k(setName(--- addImports((including 'K-LIST-LABELS .),
 suffixImports(Q,M,lists2kImports(MS)), qid(string(getName(M)) + string(Q))), Flat, pseudoKSupersorts(getSubsorts(Flat))) .

 op makeLists2k : Module Module SubsortDeclSet ~> Module .
 eq makeLists2k(M, Flat, SSDS) 
  = listsModule(M, Flat, coGetOps(pseudoKOps(getOps(Flat)),getSupersorts(SSDS)),  processSupersorts(getOps(Flat), SSDS)) .
 
 op listsModule : Module  Module OpDeclSet CTORSMap ~> Module .
 eq listsModule(M, Flat, OPDS, CTORS)
  = setOps(
   setRls(
   setEqs(
   setMbs(
   removeSubsorts(
   removeSorts(
    M
    , getSupersorts(getKeys(CTORS)))
    , getKeys(CTORS))
    , listsMbs(Flat, getOps(Flat), OPDS, CTORS, getMbs(M)))
    , listsEqs(Flat, getOps(Flat), OPDS, CTORS, getEqs(M)))
    , listsRls(Flat, getOps(Flat), OPDS, CTORS, getRls(M)))
    , listsOps(OPDS, CTORS, getOps(M)))
  .

 op listsOps : OpDeclSet CTORSMap OpDeclSet ~> OpDeclSet .
 eq listsOps(OPDS, CTORS, Ops Op)
  =  listsOps(OPDS, CTORS, Ops) listsOp(Op, OPDS, CTORS) .
 eq listsOps(OPDS, CTORS, none) = none .

 op listsOp : OpDecl OpDeclSet CTORSMap ~> OpDeclSet .
 eq listsOp(Op, OPDS, CTORS) 
  = if Op in OPDS then listsKOp(Op, CTORS) else listsOp(Op, CTORS) fi .

 op listsKOp : OpDecl CTORSMap ~> OpDeclSet .
 eq listsKOp((op Q : Tl -> T [AS] .), CTORS)
  = (op Q : listsKTypes(Tl, CTORS) -> T [AS listsMetadata(Tl,CTORS)] .) .

 op listsMetadata : TypeList CTORSMap ~> AttrSet .
 eq listsMetadata(Tl, CTORS) = listsMetadata(1, Tl, CTORS) .

 op listsMetadata : Nat TypeList CTORSMap ~> AttrSet .
 eq listsMetadata(N, T Tl, CTORS (subsort T' < T .) |-> Q[Trm]) 
  = metadata("list(" + string(N,10) + ":" + string(Q) + ":" + string(T') + ")") 
    listsMetadata(s N, Tl, CTORS (subsort T' < T .) |-> Trm).
 eq listsMetadata(N, T Tl, CTORS) = listsMetadata(s N, Tl, CTORS) [owise] .
 eq listsMetadata(N, nil, CTORS) = none .

 op listsKTypes : TypeList CTORSMap ~> TypeList .
 eq listsKTypes(T Tl, CTORS (subsort T' < T .) |-> Trm) 
  = K listsTypes(Tl, CTORS (subsort T' < T .) |-> Trm).
 eq listsKTypes(T Tl, CTORS) = T listsKTypes(Tl, CTORS) [owise] .
 eq listsKTypes(nil, CTORS) = nil .

 op listsOp : OpDecl CTORSMap ~> OpDeclSet .
 eq listsOp((op Q : Tl -> T [AS] .), CTORS (subsort T' < T .) |-> Q[Trm])
  = (op listWrapperS(Q) : nil -> KHybridLabel [metadata("list wrapper")] .) .
 ceq listsOp((op Q' : nil -> T [AS] .), CTORS (subsort T' < T .) |-> Q[Trm])
   = none if getName(Trm) = Q' .
 eq listsOp((op Q : Tl -> T [AS] .), CTORS)
  = (op Q : listsTypes(Tl, CTORS) -> listsTypes(T, CTORS) [AS] .) .

 op listsTypes : TypeList CTORSMap ~> TypeList .
 eq listsTypes(T Tl, CTORS (subsort T' < T .) |-> Trm) 
  = klistType(T') listsTypes(Tl, CTORS (subsort T' < T .) |-> Trm).
 eq listsTypes(T Tl, CTORS) = T listsTypes(Tl, CTORS) [owise] .
 eq listsTypes(nil, CTORS) = nil .

 op listsMbs : Module OpDeclSet OpDeclSet CTORSMap MembAxSet ~> MembAxSet .
 eq listsMbs(M, OPDS, OPDS', CTORS, Mbs Mb)
  =  listsMbs(M, OPDS, OPDS', CTORS, Mbs) listsMb(Mb, M, OPDS, OPDS', CTORS) .
 eq listsMbs(M, OPDS, OPDS', CTORS, none) = none .

 op listsMb : MembAx Module OpDeclSet OpDeclSet CTORSMap ~> MembAx .
 eq listsMb((mb T1 : T [AS] .), M, OPDS, OPDS', CTORS)
  = (mb listsT(T1, getKind(M,T), M, OPDS, OPDS', CTORS) : T [AS] .) .
 eq listsMb((cmb T1 : T if Cond [AS] .), M, OPDS, OPDS', CTORS)
  = (cmb listsT(T1, getKind(M,T), M, OPDS, OPDS', CTORS) : T if Cond [AS] .) .


 op listsEqs : Module OpDeclSet OpDeclSet CTORSMap EquationSet ~> EquationSet .
 eq listsEqs(M, OPDS, OPDS', CTORS, Eqs Eq)
  =  listsEqs(M, OPDS, OPDS', CTORS, Eqs) listsEq(Eq, M, OPDS, OPDS', CTORS) .
 eq listsEqs(M, OPDS, OPDS', CTORS, none) = none .

 op listsEq : Equation Module OpDeclSet OpDeclSet CTORSMap ~> Equation .
 eq listsEq((eq T1 = T2 [AS] .), M, OPDS, OPDS', CTORS)
  = (eq listsT(T1, getKind(M,leastSort(M,T1)), M, OPDS, OPDS', CTORS) 
      = listsT(T2, getKind(M,leastSort(M,T1)), M, OPDS, OPDS', CTORS) [AS] .) .
 eq listsEq((ceq T1 = T2 if Cond [AS] .), M, OPDS, OPDS', CTORS)
  = (ceq listsT(T1, getKind(M,leastSort(M,T1)), M, OPDS, OPDS', CTORS) 
       = listsT(T2, getKind(M,leastSort(M,T1)), M, OPDS, OPDS', CTORS) 
      if Cond [AS] .) .

 op listsRls : Module OpDeclSet OpDeclSet CTORSMap RuleSet ~> RuleSet .
 eq listsRls(M, OPDS, OPDS', CTORS, Rls Rl)
  =  listsRls(M, OPDS, OPDS', CTORS, Rls) listsRl(Rl, M, OPDS, OPDS', CTORS) .
 eq listsRls(M, OPDS, OPDS', CTORS, none) = none .

 op listsRl : Rule Module OpDeclSet OpDeclSet CTORSMap ~> Rule .
 eq listsRl((rl T1 => T2 [AS] .), M, OPDS, OPDS', CTORS)
  = (rl listsT(T1, getKind(M,leastSort(M,T1)), M, OPDS, OPDS', CTORS) 
     => listsT(T2, getKind(M,leastSort(M,T1)), M, OPDS, OPDS', CTORS) [AS] .) .
 eq listsRl((crl T1 => T2 if Cond [AS] .), M, OPDS, OPDS', CTORS)
  = (crl listsT(T1, getKind(M,leastSort(M,T1)), M, OPDS, OPDS', CTORS) 
      => listsT(T2, getKind(M,leastSort(M,T1)), M, OPDS, OPDS', CTORS) 
      if Cond [AS] .) .

 op listsTs : TermList TypeList Module OpDeclSet OpDeclSet CTORSMap 
    ~> TermList .
 eq listsTs((Trm,Trms),T Tl, M, OPDS, OPDS', CTORS)
  = listsT(Trm,T,M, OPDS,OPDS', CTORS), 
    listsTs(Trms, Tl, M, OPDS, OPDS', CTORS) .
 eq listsTs(empty, nil, M, OPDS, OPDS', CTORS) = empty .

 op listsT : Term Type Module OpDeclSet OpDeclSet CTORSMap ~> Term .
 eq listsT(C, T, M, OPDS, OPDS', CTORS) = listsCV(C, getType(C), CTORS) .
 eq listsT(V, T, M, OPDS, OPDS', CTORS) = listsCV(V, getType(V), CTORS)  .
 eq listsT('if_then_else_fi[Trms],T,M,OPDS,OPDS', CTORS)
  = 'if_then_else_fi[listsTs(Trms, 'Bool T T, M, OPDS,OPDS', CTORS)] .
 ceq listsT(Q[Trms],T,M,OPDS,OPDS', CTORS)
   = Q[listsTs(Trms, T T, M, OPDS, OPDS', CTORS)] if  Q = replaceS .
 eq listsT(Q[Trms],T,M,OPDS,OPDS', CTORS (subsort T' < T .) |-> Q[Trm])
  = kList(listsTs(Trms, T T, M, OPDS, OPDS', CTORS (subsort T' < T .) |-> Q[Trm])) .
 eq listsT(Q[Trms], T, M, OPDS, OPDS', CTORS)
  = listsT(Q[Trms], T, M, OPDS, OPDS', CTORS, findOp(M, OPDS,Q, leastSorts(M, Trms), T)) [owise] .

 op listsT : Term Type Module OpDeclSet OpDeclSet CTORSMap OpDecl ~> Term .
 eq listsT(Q[Trms], T, M, OPDS, OPDS', CTORS, Op)
  = if Op in OPDS' 
    then Q[listsTKs(Trms, getTypes(countTerms(Trms), Op), M, OPDS, OPDS', CTORS)]
    else Q[listsTs(Trms, getTypes(countTerms(Trms), Op), M, OPDS, OPDS', CTORS)]
    fi .

 op listsCV : Term Type CTORSMap ~> Term .
 eq listsCV(C, T, CTORS (subsort T' < T .) |-> Q[C])
  = nilKList .
 eq listsCV(C, T,  CTORS (subsort T' < T .) |-> Trm)
  = mkConstant(getName(C), klistType(T')) .
 eq listsCV(C, T, CTORS) = C [owise] .
 eq listsCV(V, T,  CTORS (subsort T' < T .) |-> Trm)
  = mkVariable(getName(V), klistType(T')) .
 eq listsCV(V, T, CTORS) = V [owise] .


 op listsTKs : TermList TypeList Module OpDeclSet OpDeclSet CTORSMap 
    ~> TermList .
 eq listsTKs(empty, nil, M, OPDS, OPDS', CTORS) = empty .
 eq listsTKs((Trm,Trms), (T Tl), M, OPDS, OPDS', CTORS ((subsort T' < T .) |-> Trm'))
  = wrapList(T', Trm',listsT(Trm, T, M, OPDS, OPDS', CTORS ((subsort T' < T .) |-> Trm'))), 
    listsTKs(Trms, Tl, M, OPDS, OPDS', ((subsort T' < T .) |-> Trm') CTORS) .
 eq listsTKs((Trm,Trms), (T Tl), M, OPDS, OPDS', CTORS) 
  = listsT(Trm, T, M, OPDS, OPDS', CTORS),listsTKs(Trms, Tl, M, OPDS, OPDS', CTORS) [owise] .


 sort CTORSMap .
 op _|->_ : SubsortDecl Term -> CTORSMap .
 op __ : CTORSMap CTORSMap -> CTORSMap [assoc comm id: empty] .
 op empty : -> CTORSMap .

 op getKeys : CTORSMap -> SubsortDeclSet .
 eq getKeys(empty) = none .
 eq getKeys(CTORS SSD |-> Trm) = getKeys(CTORS) SSD .

 op processSupersorts : OpDeclSet SubsortDeclSet ~> CTORSMap .
 eq processSupersorts(OPDS, none) = empty .
 eq processSupersorts(OPDS, (subsort T < T' .) SSDS)
  = ((subsort T < T' .) |-> getListTerm(T', OPDS))
    processSupersorts(OPDS, SSDS) .

  op getListTerm : Type OpDeclSet ~> Term .
  eq getListTerm(T, (op Q : T T -> T [assoc id(Trm) AS] .) OPDS) = Q[Trm] .
endfm


